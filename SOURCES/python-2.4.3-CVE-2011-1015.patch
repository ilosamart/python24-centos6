diff -up Python-2.4.3/Lib/CGIHTTPServer.py.CVE-2011-1015 Python-2.4.3/Lib/CGIHTTPServer.py
--- Python-2.4.3/Lib/CGIHTTPServer.py.CVE-2011-1015	2004-08-29 12:53:26.000000000 -0400
+++ Python-2.4.3/Lib/CGIHTTPServer.py	2011-04-14 19:42:22.000000000 -0400
@@ -70,24 +70,18 @@ class CGIHTTPRequestHandler(SimpleHTTPSe
     def is_cgi(self):
         """Test whether self.path corresponds to a CGI script.
 
-        Return a tuple (dir, rest) if self.path requires running a
-        CGI script, None if not.  Note that rest begins with a
-        slash if it is not empty.
-
-        The default implementation tests whether the path
-        begins with one of the strings in the list
-        self.cgi_directories (and the next character is a '/'
-        or the end of the string).
-
+        Returns True and updates the cgi_info attribute to the tuple
+        (dir, rest) if self.path requires running a CGI script.
+        Returns False otherwise.
+
+        The default implementation tests whether the normalized url
+        path begins with one of the strings in self.cgi_directories
+        (and the next character is a '/' or the end of the string).
         """
-
-        path = self.path
-
-        for x in self.cgi_directories:
-            i = len(x)
-            if path[:i] == x and (not path[i:] or path[i] == '/'):
-                self.cgi_info = path[:i], path[i+1:]
-                return True
+        splitpath = _url_collapse_path_split(self.path)
+        if splitpath[0] in self.cgi_directories:
+            self.cgi_info = splitpath
+            return True
         return False
 
     cgi_directories = ['/cgi-bin', '/htbin']
@@ -305,6 +299,46 @@ class CGIHTTPRequestHandler(SimpleHTTPSe
                 self.log_message("CGI script exited OK")
 
 
+# TODO(gregory.p.smith): Move this into an appropriate library.
+def _url_collapse_path_split(path):
+    """
+    Given a URL path, remove extra '/'s and '.' path elements and collapse
+    any '..' references.
+
+    Implements something akin to RFC-2396 5.2 step 6 to parse relative paths.
+
+    Returns: A tuple of (head, tail) where tail is everything after the final /
+    and head is everything before it.  Head will always start with a '/' and,
+    if it contains anything else, never have a trailing '/'.
+
+    Raises: IndexError if too many '..' occur within the path.
+    """
+    # Similar to os.path.split(os.path.normpath(path)) but specific to URL
+    # path semantics rather than local operating system semantics.
+    path_parts = []
+    for part in path.split('/'):
+        if part == '.':
+            path_parts.append('')
+        else:
+            path_parts.append(part)
+    # Filter out blank non trailing parts before consuming the '..'.
+    path_parts = [part for part in path_parts[:-1] if part] + path_parts[-1:]
+    if path_parts:
+        tail_part = path_parts.pop()
+    else:
+        tail_part = ''
+    head_parts = []
+    for part in path_parts:
+        if part == '..':
+            head_parts.pop()
+        else:
+            head_parts.append(part)
+    if tail_part and tail_part == '..':
+        head_parts.pop()
+        tail_part = ''
+    return ('/' + '/'.join(head_parts), tail_part)
+
+
 nobody = None
 
 def nobody_uid():
diff -up Python-2.4.3/Lib/test/test_httpservers.py.CVE-2011-1015 Python-2.4.3/Lib/test/test_httpservers.py
--- Python-2.4.3/Lib/test/test_httpservers.py.CVE-2011-1015	2011-04-14 19:05:59.000000000 -0400
+++ Python-2.4.3/Lib/test/test_httpservers.py	2011-04-14 19:59:51.000000000 -0400
@@ -0,0 +1,406 @@
+"""Unittests for the various HTTPServer modules.
+
+Written by Cody A.W. Somerville <cody-somerville@ubuntu.com>,
+Josip Dzolonga, and Michael Otteneder for the 2007/08 GHOP contest.
+"""
+
+from BaseHTTPServer import BaseHTTPRequestHandler, HTTPServer
+from SimpleHTTPServer import SimpleHTTPRequestHandler
+from CGIHTTPServer import CGIHTTPRequestHandler
+import CGIHTTPServer
+
+import os
+import sys
+import base64
+import shutil
+import urllib
+import httplib
+import tempfile
+import threading
+
+from time import sleep
+
+import unittest
+from test import test_support
+
+
+class NoLogRequestHandler:
+    def log_message(self, *args):
+        # don't write log messages to stderr
+        pass
+
+
+class TestServerThread(threading.Thread):
+    def __init__(self, test_object, request_handler):
+        threading.Thread.__init__(self)
+        self.request_handler = request_handler
+        self.test_object = test_object
+        self.__shutdown_request = False
+
+    def run(self):
+        self.server = HTTPServer(('', 0), self.request_handler)
+        self.test_object.PORT = self.server.socket.getsockname()[1]
+        self.test_object.server_started.set()
+        self.test_object = None
+        
+        try:
+            while 1:
+                sleep(0.05)
+                if self.__shutdown_request:
+                    break
+                else:
+                    self.server.handle_request()
+        finally:
+            self.server.server_close()
+
+    def stop(self):
+        self.__shutdown_request = True
+
+
+class BaseTestCase(unittest.TestCase):
+    def setUp(self):
+        self.server_started = threading.Event()
+        self.thread = TestServerThread(self, self.request_handler)
+        # FIXME:
+        self.thread.daemon = True
+        self.thread.start()
+        self.server_started.wait()
+
+    def tearDown(self):
+        self.thread.stop()
+
+    def request(self, uri, method='GET', body=None, headers={}):
+        self.connection = httplib.HTTPConnection('localhost', self.PORT)
+        self.connection.request(method, uri, body, headers)
+        return self.connection.getresponse()
+
+
+class BaseHTTPServerTestCase(BaseTestCase):
+    class request_handler(NoLogRequestHandler, BaseHTTPRequestHandler):
+        protocol_version = 'HTTP/1.1'
+        default_request_version = 'HTTP/1.1'
+
+        def do_TEST(self):
+            self.send_response(204)
+            self.send_header('Content-Type', 'text/html')
+            self.send_header('Connection', 'close')
+            self.end_headers()
+
+        def do_KEEP(self):
+            self.send_response(204)
+            self.send_header('Content-Type', 'text/html')
+            self.send_header('Connection', 'keep-alive')
+            self.end_headers()
+
+        def do_KEYERROR(self):
+            self.send_error(999)
+
+        def do_CUSTOM(self):
+            self.send_response(999)
+            self.send_header('Content-Type', 'text/html')
+            self.send_header('Connection', 'close')
+            self.end_headers()
+
+    def setUp(self):
+        BaseTestCase.setUp(self)
+        self.con = httplib.HTTPConnection('localhost', self.PORT)
+        self.con.connect()
+
+    def test_command(self):
+        self.con.request('GET', '/')
+        res = self.con.getresponse()
+        self.assertEquals(res.status, 501)
+
+    def test_request_line_trimming(self):
+        self.con._http_vsn_str = 'HTTP/1.1\n'
+        self.con.putrequest('GET', '/')
+        self.con.endheaders()
+        res = self.con.getresponse()
+        self.assertEquals(res.status, 501)
+
+    def test_header_close(self):
+        self.con.putrequest('GET', '/')
+        self.con.putheader('Connection', 'close')
+        self.con.endheaders()
+        res = self.con.getresponse()
+        self.assertEquals(res.status, 501)
+
+    def test_head_keep_alive(self):
+        self.con._http_vsn_str = 'HTTP/1.1'
+        self.con.putrequest('GET', '/')
+        self.con.putheader('Connection', 'keep-alive')
+        self.con.endheaders()
+        res = self.con.getresponse()
+        self.assertEquals(res.status, 501)
+
+    def test_handler(self):
+        self.con.request('TEST', '/')
+        res = self.con.getresponse()
+        self.assertEquals(res.status, 204)
+
+    def test_return_header_keep_alive(self):
+        self.con.request('KEEP', '/')
+        res = self.con.getresponse()
+        self.assertEquals(res.getheader('Connection'), 'keep-alive')
+        self.con.request('TEST', '/')
+
+    def test_internal_key_error(self):
+        self.con.request('KEYERROR', '/')
+        res = self.con.getresponse()
+        self.assertEquals(res.status, 999)
+
+    def test_return_custom_status(self):
+        self.con.request('CUSTOM', '/')
+        res = self.con.getresponse()
+        self.assertEquals(res.status, 999)
+
+
+class SimpleHTTPServerTestCase(BaseTestCase):
+    class request_handler(NoLogRequestHandler, SimpleHTTPRequestHandler):
+        pass
+
+    def setUp(self):
+        BaseTestCase.setUp(self)
+        self.cwd = os.getcwd()
+        basetempdir = tempfile.gettempdir()
+        os.chdir(basetempdir)
+        self.data = 'We are the knights who say Ni!'
+        self.tempdir = tempfile.mkdtemp(dir=basetempdir)
+        self.tempdir_name = os.path.basename(self.tempdir)
+        temp = open(os.path.join(self.tempdir, 'test'), 'wb')
+        temp.write(self.data)
+        temp.close()
+
+    def tearDown(self):
+        try:
+            os.chdir(self.cwd)
+            try:
+                shutil.rmtree(self.tempdir)
+            except:
+                pass
+        finally:
+            BaseTestCase.tearDown(self)
+
+    def check_status_and_reason(self, response, status, data=None):
+        body = response.read()
+        self.assert_(response)
+        self.assertEquals(response.status, status)
+        self.assert_(response.reason != None)
+        if data:
+            self.assertEqual(data, body)
+
+    def test_get(self):
+        #constructs the path relative to the root directory of the HTTPServer
+        response = self.request(self.tempdir_name + '/test')
+        self.check_status_and_reason(response, 200, data=self.data)
+        response = self.request(self.tempdir_name + '/')
+        self.check_status_and_reason(response, 200)
+        response = self.request('/ThisDoesNotExist')
+        self.check_status_and_reason(response, 404)
+        response = self.request('/' + 'ThisDoesNotExist' + '/')
+        self.check_status_and_reason(response, 404)
+        f = open(os.path.join(self.tempdir_name, 'index.html'), 'w')
+        response = self.request('/' + self.tempdir_name + '/')
+        self.check_status_and_reason(response, 200)
+        if os.name == 'posix':
+            # chmod won't work as expected on Windows platforms
+            os.chmod(self.tempdir, 0)
+            response = self.request(self.tempdir_name + '/')
+            self.check_status_and_reason(response, 404)
+            os.chmod(self.tempdir, 0755)
+
+    def test_head(self):
+        response = self.request(
+            self.tempdir_name + '/test', method='HEAD')
+        self.check_status_and_reason(response, 200)
+        self.assertEqual(response.getheader('content-length'),
+                         str(len(self.data)))
+        self.assertEqual(response.getheader('content-type'),
+                         'application/octet-stream')
+
+    def test_invalid_requests(self):
+        response = self.request('/', method='FOO')
+        self.check_status_and_reason(response, 501)
+        # requests must be case sensitive,so this should fail too
+        response = self.request('/', method='get')
+        self.check_status_and_reason(response, 501)
+        response = self.request('/', method='GETs')
+        self.check_status_and_reason(response, 501)
+
+
+cgi_file1 = """\
+#!%s
+
+print "Content-type: text/html"
+print
+print "Hello World"
+"""
+
+cgi_file2 = """\
+#!%s
+import cgi
+
+print "Content-type: text/html"
+print
+
+form = cgi.FieldStorage()
+print "%%s, %%s, %%s" %% (form.getfirst("spam"), form.getfirst("eggs"),\
+              form.getfirst("bacon"))
+"""
+
+class CGIHTTPServerTestCase(BaseTestCase):
+    class request_handler(NoLogRequestHandler, CGIHTTPRequestHandler):
+        pass
+
+    def setUp(self):
+        BaseTestCase.setUp(self)
+        self.parent_dir = tempfile.mkdtemp()
+        self.cgi_dir = os.path.join(self.parent_dir, 'cgi-bin')
+        os.mkdir(self.cgi_dir)
+
+        # The shebang line should be pure ASCII: use symlink if possible.
+        # See issue #7668.
+        if hasattr(os, 'symlink'):
+            self.pythonexe = os.path.join(self.parent_dir, 'python')
+            os.symlink(sys.executable, self.pythonexe)
+        else:
+            self.pythonexe = sys.executable
+
+        self.file1_path = os.path.join(self.cgi_dir, 'file1.py')
+        file1 = open(self.file1_path, 'w')
+        try:
+            file1.write(cgi_file1 % self.pythonexe)
+            os.chmod(self.file1_path, 0777)
+        finally:
+            file1.close()
+
+        self.file2_path = os.path.join(self.cgi_dir, 'file2.py')
+        file2 = open(self.file2_path, 'w')
+        try:
+            file2.write(cgi_file2 % self.pythonexe)
+            os.chmod(self.file2_path, 0777)
+        finally:
+            file2.close()
+
+        self.cwd = os.getcwd()
+        os.chdir(self.parent_dir)
+
+    def tearDown(self):
+        try:
+            os.chdir(self.cwd)
+            if self.pythonexe != sys.executable:
+                os.remove(self.pythonexe)
+            os.remove(self.file1_path)
+            os.remove(self.file2_path)
+            os.rmdir(self.cgi_dir)
+            os.rmdir(self.parent_dir)
+        finally:
+            BaseTestCase.tearDown(self)
+
+    def test_url_collapse_path_split(self):
+        test_vectors = {
+            '': ('/', ''),
+            '..': IndexError,
+            '/.//..': IndexError,
+            '/': ('/', ''),
+            '//': ('/', ''),
+            '/\\': ('/', '\\'),
+            '/.//': ('/', ''),
+            'cgi-bin/file1.py': ('/cgi-bin', 'file1.py'),
+            '/cgi-bin/file1.py': ('/cgi-bin', 'file1.py'),
+            'a': ('/', 'a'),
+            '/a': ('/', 'a'),
+            '//a': ('/', 'a'),
+            './a': ('/', 'a'),
+            './C:/': ('/C:', ''),
+            '/a/b': ('/a', 'b'),
+            '/a/b/': ('/a/b', ''),
+            '/a/b/c/..': ('/a/b', ''),
+            '/a/b/c/../d': ('/a/b', 'd'),
+            '/a/b/c/../d/e/../f': ('/a/b/d', 'f'),
+            '/a/b/c/../d/e/../../f': ('/a/b', 'f'),
+            '/a/b/c/../d/e/.././././..//f': ('/a/b', 'f'),
+            '../a/b/c/../d/e/.././././..//f': IndexError,
+            '/a/b/c/../d/e/../../../f': ('/a', 'f'),
+            '/a/b/c/../d/e/../../../../f': ('/', 'f'),
+            '/a/b/c/../d/e/../../../../../f': IndexError,
+            '/a/b/c/../d/e/../../../../f/..': ('/', ''),
+        }
+        for path, expected in test_vectors.iteritems():
+            if expected is IndexError:
+                self.assertRaises(expected,
+                                  CGIHTTPServer._url_collapse_path_split, path)
+            else:
+                actual = CGIHTTPServer._url_collapse_path_split(path)
+                self.assertEquals(expected, actual,
+                                  msg='path = %r\nGot:    %r\nWanted: %r' % (
+                                  path, actual, expected))
+
+    def test_headers_and_content(self):
+        res = self.request('/cgi-bin/file1.py')
+        self.assertEquals(('Hello World\n', 'text/html', 200), \
+             (res.read(), res.getheader('Content-type'), res.status))
+
+    def test_post(self):
+        params = urllib.urlencode({'spam' : 1, 'eggs' : 'python', 'bacon' : 123456})
+        headers = {'Content-type' : 'application/x-www-form-urlencoded'}
+        res = self.request('/cgi-bin/file2.py', 'POST', params, headers)
+
+        self.assertEquals(res.read(), '1, python, 123456\n')
+
+    def test_invaliduri(self):
+        res = self.request('/cgi-bin/invalid')
+        res.read()
+        self.assertEquals(res.status, 404)
+
+    def test_authorization(self):
+        headers = {'Authorization' : 'Basic %s' % \
+                base64.b64encode('username:pass')}
+        res = self.request('/cgi-bin/file1.py', 'GET', headers=headers)
+        self.assertEquals(('Hello World\n', 'text/html', 200), \
+             (res.read(), res.getheader('Content-type'), res.status))
+
+    def test_no_leading_slash(self):
+        # http://bugs.python.org/issue2254
+        res = self.request('cgi-bin/file1.py')
+        self.assertEquals(('Hello World\n', 'text/html', 200),
+             (res.read(), res.getheader('Content-type'), res.status))
+
+# Taken from 2.6's test.test_support:
+def reap_children():
+    """Use this function at the end of test_main() whenever sub-processes
+    are started.  This will help ensure that no extra children (zombies)
+    stick around to hog resources and create problems when looking
+    for refleaks.
+    """
+
+    # Reap all our dead child processes so we don't leave zombies around.
+    # These hog resources and might be causing some of the buildbots to die.
+    if hasattr(os, 'waitpid'):
+        any_process = -1
+        while True:
+            try:
+                # This will raise an exception on Windows.  That's ok.
+                pid, status = os.waitpid(any_process, os.WNOHANG)
+                if pid == 0:
+                    break
+            except:
+                break
+                    
+                    
+def test_main(verbose=None):
+    cwd = os.getcwd()
+    env = os.environ.copy()
+    try:
+        test_support.run_unittest(BaseHTTPServerTestCase,
+                                  SimpleHTTPServerTestCase,
+                                  CGIHTTPServerTestCase
+                                  )
+    finally:
+        reap_children()
+        os.environ.clear()
+        os.environ.update(env)
+        os.chdir(cwd)
+
+if __name__ == '__main__':
+    test_main()
