diff --git a/Demo/embed/demo.c b/Demo/embed/demo.c
index 6005f13..8d0297c 100644
--- a/Demo/embed/demo.c
+++ b/Demo/embed/demo.c
@@ -16,10 +16,19 @@ main(int argc, char **argv)
 	initxyzzy();
 
 	/* Define sys.argv.  It is up to the application if you
-	   want this; you can also let it undefined (since the Python 
-	   code is generally not a main program it has no business
-	   touching sys.argv...) */
-	PySys_SetArgv(argc, argv);
+	  want this; you can also leave it undefined (since the Python
+	  code is generally not a main program it has no business
+	  touching sys.argv...)
+
+	  If the third argument is true, sys.path is modified to include
+	  either the directory containing the script named by argv[0], or
+	  the current working directory.  This can be risky; if you run
+	  an application embedding Python in a directory controlled by
+	  someone else, attackers could put a Trojan-horse module in the
+	  directory (say, a file named os.py) that your application would
+	  then import and run.
+	*/
+	PySys_SetArgvEx(argc, argv, 0);
 
 	/* Do some application specific code */
 	printf("Hello, brave new world\n\n");
diff --git a/Include/sysmodule.h b/Include/sysmodule.h
index 1c9b187..954ee65 100644
--- a/Include/sysmodule.h
+++ b/Include/sysmodule.h
@@ -11,6 +11,7 @@ PyAPI_FUNC(PyObject *) PySys_GetObject(char *);
 PyAPI_FUNC(int) PySys_SetObject(char *, PyObject *);
 PyAPI_FUNC(FILE *) PySys_GetFile(char *, FILE *);
 PyAPI_FUNC(void) PySys_SetArgv(int, char **);
+PyAPI_FUNC(void) PySys_SetArgvEx(int, char **, int);
 PyAPI_FUNC(void) PySys_SetPath(char *);
 
 PyAPI_FUNC(void) PySys_WriteStdout(const char *format, ...)
diff --git a/Misc/NEWS b/Misc/NEWS
index cb2b13f..0ee2d49 100644
--- a/Misc/NEWS
+++ b/Misc/NEWS
@@ -116,6 +116,14 @@ Extension Modules
 
 - Fix parse errors in the readline module when compiling without threads.
 
+C-API
+-----
+
+- Issue #5753: A new C API function, :cfunc:`PySys_SetArgvEx`, allows
+  embedders of the interpreter to set sys.argv without also modifying
+  sys.path.  This helps fix `CVE-2008-5983
+  <http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-5983>`_.
+
 Library
 -------
 
diff --git a/Python/sysmodule.c b/Python/sysmodule.c
index bc0e789..0ce02a9 100644
--- a/Python/sysmodule.c
+++ b/Python/sysmodule.c
@@ -1175,7 +1175,7 @@ makeargvobject(int argc, char **argv)
 }
 
 void
-PySys_SetArgv(int argc, char **argv)
+PySys_SetArgvEx(int argc, char **argv, int updatepath)
 {
 #ifndef HAVE_CANONICALIZE_FILE_NAME
 #if defined(HAVE_REALPATH)
@@ -1190,7 +1190,7 @@ PySys_SetArgv(int argc, char **argv)
 		Py_FatalError("no mem for sys.argv");
 	if (PySys_SetObject("argv", av) != 0)
 		Py_FatalError("can't assign sys.argv");
-	if (path != NULL) {
+	if (updatepath && path != NULL) {
 		char *argv0 = argv[0];
 		char *p = NULL;
 		int n = 0;
@@ -1340,6 +1340,12 @@ PySys_SetArgv(int argc, char **argv)
 	Py_DECREF(av);
 }
 
+void
+PySys_SetArgv(int argc, char **argv)
+{
+    PySys_SetArgvEx(argc, argv, 1);
+}
+
 
 /* APIs to write to sys.stdout or sys.stderr using a printf-like interface.
    Adapted from code submitted by Just van Rossum.
